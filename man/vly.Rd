% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions.R
\name{vly}
\alias{vly}
\title{vly}
\usage{
vly(p, q, adj = T, indices = NULL, at = NULL, mode = 0,
  fold = NULL, p_threshold = 0, nt = 5000, nv = 1000,
  scale = c("p", "z"), closed = T, ...)
}
\arguments{
\item{p}{principal p-values}

\item{q}{conditional p-values}

\item{adj}{adjust cFDR values and hence curves L using estimate of Pr(H0|Pj<pj)}

\item{indices}{compute v(L) at indices of points. Overrides parameter at if set.}

\item{at}{cfdr cutoff/cutoffs. Defaults to null}

\item{mode}{set to 0 to leave all of 'indices' in, 1 (NOT CURRENTLY SUPPORTED) to remove each index only when computing L at that point, 2 to remove all of 'indices' from p,q}

\item{fold}{If mode=2, only compute L-curves using points not in 'fold'.}

\item{p_threshold}{if H0 is to be rejected automatically whenever p<p_threshold, include this in all regions L}

\item{nt}{number of test points in x-direction, default 5000}

\item{nv}{resolution for constructing L-curves, default 1000}

\item{scale}{return curves on the p- or z- plane. Y values are equally spaced on the z-plane.}

\item{closed}{determines whether curves are closed polygons encircling regions L (closed=T), or lines indicating the rightmost border of regions L}

\item{...}{other parameters passed to function kde2d. Can be used to set a non-Gaussian kernel.}
}
\value{
list containing elements x, y. Assuming n curves are calculated and closed=T (where n=length(indices) or length(at)), x is a matrix of dimension n x (4+nv), y ix a vector of length (4+nv).
}
\description{
Return co-ordinates of L-regions for cFDR method using kernel density method, with or without estimation
 of Pr(H0|Pj<pj).
}
\details{
Estimates empirical distribution of (P,Q) by fitting a kernel density estimate to observed values.
}
\examples{
# Generate standardised simulated dataset
set.seed(1); n=10000; n1p=100; n1pq=100; n1q=100
zp=c(rnorm(n1p,sd=3), rnorm(n1q,sd=1),rnorm(n1pq,sd=3), rnorm(n-n1p-n1q-n1pq,sd=1))
zq=c(rnorm(n1p,sd=1), rnorm(n1q,sd=3),rnorm(n1pq,sd=3), rnorm(n-n1p-n1q-n1pq,sd=1))
p=2*pnorm(-abs(zp)); q=2*pnorm(-abs(zq))
fold_id=(1:n) \%\% 3

# points to generate L-regions for
example_indices=c(4262, 268,83,8203) #c(164,23,74)

par(mfrow=c(1,2))

v1=vly(p,q,indices=example_indices,mode=0); 
plot(p,q,cex=0.5,col="gray",xlim=c(0,0.001),ylim=c(0,1), main="All points in"); 
for (i in 1:length(example_indices)) lines(v1$x[i,],v1$y); 
for (i in 1:length(example_indices)) points(p[example_indices[i]],q[example_indices[i]],pch=16,col="blue")

v2=vly(p,q,indices=example_indices,mode=2,fold=which(fold_id==1)); 
plot(p,q,cex=0.5,col="gray",xlim=c(0,0.001),ylim=c(0,1), main="Fold removed"); 
for (i in 1:length(example_indices)) lines(v2$x[i,],v2$y); 
for (i in 1:length(example_indices)) points(p[example_indices[i]],q[example_indices[i]],pch=16,col="blue")

}
\author{
James Liley
}
